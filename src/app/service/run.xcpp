// This is -*- c++ -*- (as close to C++2a as possible)
#divert <hpp>
#import app.service.Configuration
namespace app::service {
  //
  // run - do that thing
  //
  // Does return
  //   FOREGROUND - returns at the end of program
  //   BACKGROUND - returns because the server is in the background
  //
  // Usage:
  //
  //   try {
  //     Configuration cfg{...};
  //     run(cfg);
  //   } catch (std::exception const &) {
  //     ...report the problem...
  //   }
  //
  auto run(Configuration const &) -> void;
}
#endiv
#divert <cpp>
#import app.exception.Quitting
#import app.service.constants
#import app.service.defaults
#import app.service.drop
#import autotools.autoconf.Config.tunitas.tarwater.CONFIG
#import getpid
#import httpserver.Create_Webserver
#import httpserver.Webserver
#import std.cout
#import std.move
#import tunitas.tarwater.member.load
#import tunitas.tarwater.member.Storage
#import tunitas.tarwater.service.Core
#import tunitas.tarwater.endpoint.Sync
auto app::service::run(Configuration const &cfg) -> void {
  using namespace want;
  httpserver::Webserver ws{[&cfg]() {
    httpserver::Create_Webserver specification;
    using namespace constants::server;
    specification.debug();
    specification.use_ipv6().start_method(METHOD).max_threads(THREADS);
    specification.port(cfg.service_port.value_or(defaults::SERVICE_PORT));
    return std::move(specification);
  }()};
  if (cfg.emit_pid) {
    std::cout << getpid() << std::flush;
  }
  if (cfg.drop_privileges) {
    drop(cfg);
  }
  using namespace tunitas::tarwater;
  auto store = [&cfg]() -> member::Storage {
    using ac = autotools::autoconf::Config<CONFIG>;
    auto const member_storage_filepath = cfg.member_storage.value_or(ac::pkgconfdir(), defaults::MEMBER_STORAGE);
    auto loaded = member::load(member_storage_filepath);
    if (!ok(loaded)) {
      auto &error{::options::error(cfg)};
      error << "could not load the member secret database "
	    << member_storage_filepath
	    << " because " << error_code(loaded).message() << '\n';
      throw exception::Quitting{cfg.NAME, sys::exits::CONFIG};
    }
    return value(std::move(loaded));
  }();
  //
  Core core{store};
  auto const FAMILY_SENSE = false;
  endpoint::Sync sync{core};
  ws.register_resource("/sync", &sync, FAMILY_SENSE);   // "our" standard name (same as theirs)
  ws.register_resource("/userid", &sync, FAMILY_SENSE); // "their" standard name
  // There is no 'quit' method.  The service runs forever
  ws.start(cfg.foreground.value_or(defaults::FOREGROUND));
}
#endiv
