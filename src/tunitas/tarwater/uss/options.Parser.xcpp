// This is -*- c++ -*- (as close to C++2a as possible)
#divert <fpp>
namespace tunitas::tarwater::uss::options {
  //
  // The options parser
  //
  // The lifetime of the Configuration must be longer than that of the Parser
  // The lifetime of the Specification must be longer than that of the Parser
  //
  // Usage:
  //
  //   Configuration cfg{...};
  //   options::Parser parser{cfg};
  //   auto parsed = parser(Args{c, v});
  //   if (ok(parsed)) {
  //   } else {
  //     
  //   }
  class Parser;
}
#endiv
#divert <hpp>
#import tunitas.app.options.Args
#import tunitas.app.options.Specification
#import tunitas.tarwater.uss.Configuration
#import tunitas.tarwater.uss.options.parser.Result
class tunitas::tarwater::uss::options::Parser {
public:
  using Specification = tunitas::app::options::Specification;
  inline Parser(Configuration &cfg, Specification const &);
  inline Parser(Configuration &&, Specification const &) = delete;
  inline Parser(Configuration const &, Specification &&) = delete;
  using Args = tunitas::app::options::Args;
  using Result = parser::Result;
  auto parse(Args) -> Result;
protected:
  Configuration &cfg;
  Specification const &spec;
};
#endiv
#divert <ipp>
tunitas::tarwater::uss::options::Parser::Parser(Configuration &cfg, Specification const &spec)
  : cfg{cfg}
  , spec{spec}
{ }
#endiv
#divert <cpp>
#import options.longish.Getter
#import options.longish.Step
#import std.cerr
#import std.literals
#import std.logic_error // [[FIXTHIS]] nonstd::exception::Unexpected
#import std.to_string
#import sys.exits.constants
#import tunitas.tarwater.Version
#import tunitas.tarwater.uss.Usage
#import tunitas.tarwater.uss.exception.Quitting
#import tunitas.tarwater.uss.main // for tarwater::NAME
#import tunitas.tarwater.uss.options.indicator.constants
using namespace std::literals;
auto tunitas::tarwater::uss::options::Parser::parse(Args args) -> Result {
  using namespace ::options::longish;
  Getter get{spec.shortish(), spec.longish(), args};
  for (Step step=get(); more(step); step=get()) {
    switch (code(step)) {
      namespace oi = options::indicator;
    case oi::CHR_h:
    case oi::USAGE_SUBCOMMAND:
      throw tunitas::tarwater::uss::Usage{NAME, sys::exits::OK};
    case oi::CHR_V:
    case oi::VERSION_SUBCOMMAND:
      throw tunitas::tarwater::Version{NAME};
    case oi::MISSING:
      // [[FIXTHIS,TODO]] -- resolve whether it is a short or long option as ::options::option_in_error(code)
      // [[FIXTHIS]] get a better application-level messaging & logging facility
      std::cerr << NAME << ": error, missing required value for --" << word_in_error(step) << '\n';
      throw exception::Quitting{sys::exits::USAGE};
    case oi::UNKNOWN:
      // [[FIXTHIS, TODO]] ibidem. use options::option_in_error(code)
      // [[FIXTHIS, TODO]] ibidem. better messaging.
      std::cerr << NAME << ": error, unknown option " << word_in_error(step) << '\n';
      throw exception::Quitting{sys::exits::USAGE};
    default:
      throw std::logic_error{"unexpected option code "s + std::to_string((int)code(step))}; 
    }
  }
  return Result{true, get.begin(), get.end()};
}
#endiv
